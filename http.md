# HTTP는 무엇일까요?
## HTTP
**HTTP** = **H**yper**T**ext**T**ransfer**P**rotocol  
하이퍼텍스트 문서를 교환하기 위해 사용된 통신 규약  
->웹 서버와 클라이언트 간의 통신을 하기 위한 통신 규약  
HTTP는 1989년 팀 버너스-리에 의해 처음 설계되어 인터넷을 통한 월드 와이드 웹(World-Wide Web : www)기반에서 전 세계적인 정보 공유를 이루는데 큰 역할  
HTTP는 웹에서만 사용하는 프로토콜로 TCP/IP 기반으로 한 지점에서 다른 지점(서버와 클라이언트)으로 요청과 응답을 전송

**HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜**  
웹에서 이루어지는 모든 데이터 교환이 기초, 클라이언트-서버 프로토콜  
* 클라이언트-서버 프로토콜 : 수신자(보통 웹브라우저) 측에 의해 요청이 초기화되는 프로토콜  
하나의 완전한 문서는 텍스트, 레이아웃 설명, 이미지, 비디오, 스크립트 등 불러온 하위 문서 들로 재구성
<img src="https://mdn.mozillademos.org/files/13677/Fetching_a_page.png" width="400px" height="350px"/>  
클라이언트와 서버들은 (데이터 스트림과 대조적으로) 개별적이 메시지 교환에 의해 통신  
요청(request) : 클라이언트에 의해 전송되는 메시지  
응답(response) : 요청에 대해 서버에서 응답으로 전송되는 메시지  

<img src="https://mdn.mozillademos.org/files/13673/HTTP%20&%20layers.png" width="500px" height="500px"/>  
1990년대 초에 설계된 HTTP는 거듭하여 진화해온 확장 가능한 프로토콜  
HTTP는 애플리케이션 계층의 프로토콜, 신뢰 가능한 전송 프로토콜이라면 이론상으로는 무엇이든 사용가능(TCP혹은 암호와된 TCP 연결인 TLS를 통해 전송)

## HTTP 기반 시스템의 구성요소
요청은 하나의 개체, 사용자 에이전트(프록시)에 의해 전송  
대부분의 경우, 사용자 에이전트는 브라우저지만, 무엇이든 될 수 있음  
ex) 검색 엔진 인덱스를 채워넣고 유지하기 위해 웹을 돌아다니는 로봇  
  
요청과 응답 사이에는 여러 개체들이 존재  
ex) 게이트웨이 : 다양한 작업 수행, 프록시 : 캐시 역할  
<img src="https://mdn.mozillademos.org/files/13679/Client-server-chain.png" width="500px" height="80px"/>  
브라우저와 요청을 처리하는 서버 사이에는 좀 더 많은 컴퓨터들이 존재(라우터, 모뎀 등)  
웹의 계층적인 설계 덕분에 네트워크와 전송 계층 내로 숨겨짐  
HTTP은 애플리케이션 계층의 최상위  
네트워크 문제를 진단하는 것도 중요하지만, 기본레이어들은 HTTP의 명세와는 거의 관련이 없다.

## HTTP의 특징
### 간결성
HTTP는 사람이 읽을 수 있으며 간단하게 고안  
HTTP/2가 다소 더 복잡해졌지만 HTTP메세지를 프레임별로 캡슐화하여 간결함 유지  

### 확장 가능
HTTP/1.0에서 소개 된, HTTP 헤더는 HTTP를 확장하고 실험하기 쉽게 만듦  
클라이언트와 서버가 새로운 헤더의 시맨틱에 대해 간단한 합의만 한다면 언제든지 새로운 기능 추가 가능

### 상태 X 세션 O
HTTP는 상태를 저장하지 않음(Stateless)  
동일한 연결 상에서 연속하여 전달된 두개의  요청 사이에는 연결고리가 없음  
ex) e-커머스 쇼핑 바구니처럼, 일관된 방식으로 사용자가 페이지와 상호작용하길 원할 때 문제 발생  
HTTP의 핵심은 상태가 없는 것이지만 HTTP 쿠키는 상태가 있는 세션을 만들도록 함  
헤더 확장성을 사용하여, 동일한 컨텍스트 또는 동일한 상태를 공유하기 위해 각각의 요청들에 세션을 만들도록 HTTP 쿠키가 추가

## HTTP 메시지
HTTP/1.1와 초기 HTTP 메시지 : 사람이 읽을 수 있음  
HTTP/2 : 메시지들은 새로운 이진 구조인 프레임 안으로 임베드되어, 헤더의 압축과 다중화와 같은 최적화를 가능  
본래의 HTTP 메시지의 일부분만이 이 버전의 HTTP 내에서 전송된다고 할지라도, 각 메시지의 의미들은 변화하지 않으며 클라이언트는 본래의 HTTP/1.1 요청을 (가상으로) 재구성  
HTTP/1.1 포맷 내에서 HTTP/2를 이해하는 것은 여전히 유용  

### Request HTTP 메시지
<img src="https://mdn.mozillademos.org/files/13687/HTTP_Request.png"/>

구성

- HTTP 메서드 : 보통 클라이언트가 수행하고자 하는 동작을 정의한 명사(GET : 자료를 요청할 때 사용 POST : 자료의 생성을 요청할 때 사용 PUT : 자료의 수정을 요청할 때 사용 DELETE : 자료의 삭제를 요청할 때 사용)  
- 가져오려는 리소스의 경로 : 프로토콜 (http://), 도메인 (en-US) (여기서는 developer.mozilla.org), 또는 TCP 포트 (en-US) (여기서는 80)인 요소들을 제거한 리소스의 URL  
- HTTP 프로토콜의 버전  
- 서버에 대한 추가 정보를 전달하는 선택적 헤더들  
- 메서드를 위한 전송된 리소스를 포함하는 응답의 본문과 유사한 본문

## Response HTTP 메시지
<img src="https://mdn.mozillademos.org/files/13691/HTTP_Response.png" width="500px" height="400px"/>

구성

- HTTP 프로토콜의 버전  
- 요청의 성공 여부와, 그 이유를 나타내는 상태 코드  
- 아무런 영향력이 없는, 상태 코드의 짧은 설명을 나타내는 상태 메시지  
- 요청 헤더와 비슷한 HTTP 헤더들  
- 선택 사항으로 가져온 리소스가 포함되는 본문

### Status Code (상태 코드)
상태 코드에는 굉장히 많은 종류가 있다. 모두 숫자 세 자리로 이루어져 있으며, 아래와 같이 크게 다섯 부류로 나눌 수 있다.

- 1XX (조건부 응답) : 요청을 받았으며 작업을 계속한다.
- 2XX (성공) : 클라이언트가 요청한 동작을 수신하여 이해했고 승낙했으며 성공적으로 처리했음을 가리킨다.
- 3XX (리다이렉션 완료) : 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.
- 4XX (요청 오류) : 클라이언트에 오류가 있음을 나타낸다.
- 5XX (서버 오류) : 서버가 유효한 요청을 명백하게 수행하지 못했음을 나타낸다.


### Chrome에서 HTTP header확인하기
1. Chorme에서 개발자 도구창 열기(F12 또는 Ctrl+Shift+I)
2. Network 클릭
3. 하단의 Name에서 url를 클릭하면 Header확인 가능
4. 주소를 https에서 http로 변경하면 더 자세히 알 수 있다.
### Response HTTP Message
<img src="https://user-images.githubusercontent.com/101981594/166188990-419d3a9d-e72e-48db-aa21-140a2115de4a.jpg" width="800px" height="450px"/>

### Request HTTP Message
<img src="https://user-images.githubusercontent.com/101981594/166188969-8f8a2377-7f99-4e28-9156-effe43720504.jpg" width="800px" height="450px"/>

![url](https://developer.mozilla.org/ko/docs/Web/HTTP).